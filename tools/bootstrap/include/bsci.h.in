/* -*- Mode: C; c-basic-offset:4 ; -*- */
/*
 *  (C) 2008 by Argonne National Laboratory.
 *      See COPYRIGHT in top-level directory.
 */

#ifndef BSCI_H_INCLUDED
#define BSCI_H_INCLUDED

/** @file bsci.h.in */

/*! \addtogroup bootstrap Bootstrap Control Interface
 * @{
 */

/**
 * \brief BSCI internal structure to maintain persistent information.
 */
struct HYDT_bsci_info {
    /** \brief Boostrap executable to use */
    char *bootstrap_exec;

    /** \brief Enable/disable X-forwarding */
    int  enablex;

    /** \brief Enable/disable debugging */
    int  debug;
};

/**
 * \brief Function pointers for device specific implementations of
 * different BSCI functions.
 */
struct HYDT_bsci_fns {
    /** \brief Launch processes */
    HYD_status(*launch_procs) (
        char **args, struct HYD_node *node_list, void *userp,
        HYD_status(*stdin_cb) (int fd, HYD_event_t events, void *userp),
        HYD_status(*stdout_cb) (int fd, HYD_event_t events, void *userp),
        HYD_status(*stderr_cb) (int fd, HYD_event_t events, void *userp));

    /** \brief Finalize the bootstrap control device */
    HYD_status(*finalize) (void);

    /** \brief Wait for bootstrap launched processes to complete */
    HYD_status(*wait_for_completion) (int timeout);

    /** \brief Query for node list information */
    HYD_status(*query_node_list) (struct HYD_node **node_list);

    /** \brief Query for the universe size */
    HYD_status(*query_usize) (int *size);

    /** \brief Query the ID of a proxy */
    HYD_status(*query_proxy_id) (int *proxy_id);
};

/** \cond */
extern struct HYDT_bsci_fns HYDT_bsci_fns;
extern struct HYDT_bsci_info HYDT_bsci_info;
/** \endcond */

/**
 * \brief HYDT_bsci_init - Initialize the bootstrap control device
 *
 * \param[in]   bootstrap       Bootstrap device to use
 * \param[in]   bootstrap_exec  Bootstrap helper executable to use (optional)
 * \param[in]   enablex         Enable/disable X-forwarding (hint only)
 * \param[in]   debug           Enable/disable debugging
 *
 * This function initializes the bootstrap control device. This needs
 * to be called before any other BSCI function. Implementors are
 * expected to set any bootstrap implementation specific function
 * pointers in this function to be used by later BSCI calls.
 */
HYD_status HYDT_bsci_init(char *bootstrap, char *bootstrap_exec, int enablex, int debug);


/**
 * \brief HYDT_bsci_launch_procs - Launch processes
 *
 * \param[in]   args            Arguments to be used for the launched processes
 * \param[in]   node_list       List of nodes to launch processes on
 * \param[in]   userp           Arbitrary user pointer that is passed to the callback functions
 * \param[in]   stdin_cb        Stdin callback function
 * \param[in]   stdout_cb       Stdout callback function
 * \param[in]   stderr_cb       Stderr callback function
 *
 * This function appends a proxy ID to the end of the args list and
 * uses this combined list as the executable and its arguments to
 * launch. Upper layers will need to account for this automatic
 * addition of the proxy ID.
 *
 * Bootstrap servers that perform sequential launches (one process at
 * a time), should set the proxy ID string in sequential
 * order. Bootstrap servers that perform parallel launches should set
 * the proxy ID string to "-1", but allow proxies to query their ID
 * information on each node using the HYDT_bsci_query_proxy_id
 * function.
 */
HYD_status HYDT_bsci_launch_procs(
        char **args, struct HYD_node *node_list, void *userp,
        HYD_status(*stdin_cb) (int fd, HYD_event_t events, void *userp),
        HYD_status(*stdout_cb) (int fd, HYD_event_t events, void *userp),
        HYD_status(*stderr_cb) (int fd, HYD_event_t events, void *userp));


/**
 * \brief HYDT_bsci_finalize - Finalize the bootstrap control device
 *
 * This function cleans up any relevant state that the bootstrap
 * device maintained.
 */
HYD_status HYDT_bsci_finalize(void);


/**
 * \brief HYDT_bsci_wait_for_completion - Wait for bootstrap launched processes to complete
 *
 * \param[in]  timeout        Time to wait for
 *
 * \param[ret] status         HYD_TIMED_OUT if the timer expired
 *
 * This function waits for all processes it launched to finish. The
 * bootstrap control device should keep track of the processes it is
 * launching and wait for their completion.
 */
HYD_status HYDT_bsci_wait_for_completion(int timeout);


/**
 * \brief HYDT_bsci_query_node_list - Query for node list information
 *
 * \param[out] node_list       Lists of nodes available
 *
 * This function allows the upper layers to query the available nodes.
 */
HYD_status HYDT_bsci_query_node_list(struct HYD_node **node_list);


/**
 * \brief HYDT_bsci_query_usize - Query for the universe size
 *
 * \param[out]  size       Maximum number of processes that can be launched
 *
 * If the underlying system allows for multitasking many processes on
 * a single processing element, the bootstrap server should return
 * "-1" (representing infinite). If not, it should specify the number
 * of processes that can be spawned.
 */
HYD_status HYDT_bsci_query_usize(int *size);


/**
 * \brief HYDT_bsci_query_proxy_id - Query the ID of a proxy
 *
 * \param[out]  proxy_id    My proxy ID
 *
 * This function is called by each proxy if the proxy_str_id is
 * specified as "-1" during launch.
 */
HYD_status HYDT_bsci_query_proxy_id(int *proxy_id);

/*! @} */

/* Each bootstrap server has to expose an initialization function */
@hydra_bss_init_decl@

#endif /* BSCI_H_INCLUDED */
